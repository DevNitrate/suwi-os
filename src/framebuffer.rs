use limine::framebuffer::Framebuffer;

const FONT: [[u8; 8]; 26] = [
    [0x7E, 0xFF, 0xE7, 0xE7, 0xFF, 0xFF, 0xE7, 0xE7],
    [0xFE, 0xFF, 0xE7, 0xFE, 0xFE, 0xE7, 0xFF, 0xFE],
    [0x7E, 0xFF, 0xE7, 0xE0, 0xE0, 0xE7, 0xFF, 0x7E],
    [0xFE, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0xFE],
    [0xFF, 0xFF, 0xE0, 0xFC, 0xFC, 0xE0, 0xFF, 0xFF],
    [0xFF, 0xFF, 0xE0, 0xFC, 0xFC, 0xE0, 0xE0, 0xE0],
    [0x7E, 0xFF, 0xE7, 0xE0, 0xEF, 0xE7, 0xFF, 0x7E],
    [0xE7, 0xE7, 0xE7, 0xFF, 0xFF, 0xE7, 0xE7, 0xE7],
    [0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38],
    [0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0E, 0x7E, 0x7C],
    [0xE3, 0xE7, 0xEE, 0xFC, 0xFC, 0xEE, 0xE7, 0xE3],
    [0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xFF, 0xFF],
    [0xE3, 0xF7, 0xFF, 0xFF, 0xE3, 0xE3, 0xE3, 0xE3],
    [0xE7, 0xF7, 0xF7, 0xFF, 0xFF, 0xFF, 0xEF, 0xE7],
    [0x7E, 0xFF, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0x7E],
    [0xFE, 0xFF, 0xE7, 0xFF, 0xFE, 0xE0, 0xE0, 0xE0],
    [0x7E, 0xFF, 0xE7, 0xE7, 0xE3, 0xED, 0xF6, 0x7B],
    [0xFE, 0xFF, 0xE7, 0xFF, 0xFE, 0xE7, 0xE7, 0xE7],
    [0x7E, 0xFF, 0xE0, 0xFE, 0x7F, 0x07, 0xFF, 0x7E],
    [0xFE, 0xFE, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38],
    [0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, 0x7E],
    [0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0x7E, 0x3C],
    [0xE3, 0xE3, 0xEB, 0xEB, 0xEB, 0xFF, 0x7F, 0x2A],
    [0xE7, 0xE7, 0x7E, 0x3C, 0x3C, 0x7E, 0xE7, 0xE7],
    [0xE7, 0xE7, 0xE7, 0x7E, 0x3C, 0x18, 0x18, 0x18],
    [0xFF, 0xFF, 0x0F, 0x1E, 0x78, 0xF0, 0xFF, 0xFF],
];

pub struct Color {
    value: u32
}

impl Color {
    pub fn new(framebuffer: &Framebuffer, r: u8, g: u8, b: u8) -> Self {
        let value: u32 = ((r as u32) << framebuffer.red_mask_shift()) | ((g as u32) << framebuffer.green_mask_shift()) | ((b as u32) << framebuffer.blue_mask_shift());

        Self {
            value
        }
    }

    pub fn value(&self) -> u32 {
        self.value
    }
}

pub fn write_pixel(framebuffer: &Framebuffer, x: u64, y: u64, color: &Color) {
    let pixel_offset = y * framebuffer.pitch() + x * 4;

    unsafe {
        framebuffer
            .addr()
            .add(pixel_offset as usize)
            .cast::<u32>()
            .write(color.value())
    };
}

pub fn render_rect(framebuffer: &Framebuffer, x: u64, y: u64, w: u64, h: u64, color: &Color) {
    for x in x..x+w {
        for y in y..y+h {
            write_pixel(framebuffer, x, y, color);
        }
    }
}

pub fn render_char(framebuffer: &Framebuffer, c: char, x: u64, y: u64, color: &Color, font_size: u64) {
    let glyph = &FONT[((c as u8) - 97) as usize];

    for (row, bits) in glyph.iter().enumerate() {
        for bit in 0..8 {
            if (bits >> (7 - bit)) & 1 == 1 {
                render_rect(framebuffer, x + (bit * font_size), y + (row as u64 * font_size), font_size, font_size, color);
            }
        }
    }
}

pub fn render_text(framebuffer: &Framebuffer, string: &str, x: u64, y: u64, font_size: u64, color: &Color) {
    let offset_add: u64 = (font_size * 8) + font_size;

    let mut x_offset: u64 = 0;
    let mut y_offset: u64 = 0;

    for c in string.chars() {
        let c: char = c.to_ascii_lowercase();

        if c.is_alphanumeric() {
            render_char(framebuffer, c, x + x_offset, y + y_offset, color, font_size);
            x_offset += offset_add;
        } else {
            match c {
                '\n' => {
                    y_offset += offset_add;
                    x_offset = 0;
                },
                ' ' => x_offset += offset_add,
                '\t' => x_offset += offset_add * 4,
                _ => {
                    let col: Color = Color::new(framebuffer, 255, 0, 0);
                    render_text(framebuffer, "unhandled char panic occured", x + x_offset, y + y_offset, 2, &col);
                    panic!()
                }
            }
        }
    }
}